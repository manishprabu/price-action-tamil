AWSTemplateFormatVersion: '2010-09-09'
Description: 'CloudFormation template to host a static website in an S3 bucket served via CloudFront with a custom domain.'

Parameters:
  BucketName:
    Type: String
    Description: 'The name for the S3 bucket. Must be globally unique.'
    Default: 'price-action-tamil-site'
  DomainName:
    Type: String
    Description: 'The custom domain name for the website'
    Default: 'price-action-tamil.com'
  HostedZoneId:
    Type: String
    Description: 'The Route53 Hosted Zone ID'
    Default: 'Z03717392X1FRLNERFR2F'
  CertificateArn:
    Type: String
    Description: 'The ARN of the ACM Certificate (must be in us-east-1)'

Resources:
  # S3 Bucket Configuration
  WebsiteBucket:
    Type: 'AWS::S3::Bucket'
    Properties:
      BucketName: !Ref BucketName
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true

  # CloudFront Origin Access Identity (OAI)
  CloudFrontOriginAccessIdentity:
    Type: 'AWS::CloudFront::CloudFrontOriginAccessIdentity'
    Properties:
      CloudFrontOriginAccessIdentityConfig:
        Comment: !Sub 'Access identity for ${DomainName}'

  # S3 Bucket Policy
  WebsiteBucketPolicy:
    Type: 'AWS::S3::BucketPolicy'
    Properties:
      Bucket: !Ref WebsiteBucket
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Sid: GrantCloudFrontAccess
            Effect: Allow
            Principal:
              AWS: !Sub 'arn:aws:iam::cloudfront:user/CloudFront Origin Access Identity ${CloudFrontOriginAccessIdentity}'
            Action: 's3:GetObject'
            Resource: !Join 
              - ''
              - - 'arn:aws:s3:::'
                - !Ref WebsiteBucket
                - '/*'

  # CloudFront Distribution
  WebsiteDistribution:
    Type: 'AWS::CloudFront::Distribution'
    Properties:
      DistributionConfig:
        Origins:
          - Id: S3Origin
            DomainName: !GetAtt WebsiteBucket.DomainName
            S3OriginConfig:
              OriginAccessIdentity: !Sub 'origin-access-identity/cloudfront/${CloudFrontOriginAccessIdentity}'
        Enabled: true
        DefaultRootObject: index.html
        Aliases:
          - !Ref DomainName
          - !Sub 'www.${DomainName}'
        CustomErrorResponses:
          - ErrorCode: 403
            ResponseCode: 200
            ResponsePagePath: /index.html
          - ErrorCode: 404
            ResponseCode: 200
            ResponsePagePath: /index.html
        DefaultCacheBehavior:
          TargetOriginId: S3Origin
          ForwardedValues:
            QueryString: false
            Cookies:
              Forward: none
          ViewerProtocolPolicy: redirect-to-https
          Compress: true
        ViewerCertificate:
          AcmCertificateArn: !Ref CertificateArn
          SslSupportMethod: sni-only
          MinimumProtocolVersion: TLSv1.2_2021



  # Route53 Record (Apex)
  WebsiteDNS:
    Type: 'AWS::Route53::RecordSet'
    Properties:
      HostedZoneId: !Ref HostedZoneId
      Name: !Ref DomainName
      Type: A
      AliasTarget:
        HostedZoneId: Z2FDTNDATAQYW2
        DNSName: !GetAtt WebsiteDistribution.DomainName

  # WWW Record
  WebsiteDNSWWW:
    Type: 'AWS::Route53::RecordSet'
    Properties:
      HostedZoneId: !Ref HostedZoneId
      Name: !Sub 'www.${DomainName}'
      Type: A
      AliasTarget:
        HostedZoneId: Z2FDTNDATAQYW2
        DNSName: !GetAtt WebsiteDistribution.DomainName

  # Proxy Lambda Function
  ProxyFunction:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: |
          const https = require('https');
          const url = require('url');

          exports.handler = async (event) => {
              console.log('Event:', JSON.stringify(event, null, 2));
              
              const headers = {
                  "Access-Control-Allow-Origin": "*",
                  "Access-Control-Allow-Headers": "Content-Type",
                  "Access-Control-Allow-Methods": "GET, OPTIONS"
              };

              // Handle OPTIONS preflight
              const method = event.requestContext?.http?.method || event.httpMethod;
              if (method === 'OPTIONS') {
                  return {
                      statusCode: 200,
                      headers: headers,
                      body: JSON.stringify({ message: "OPTIONS OK" })
                  };
              }

              try {
                  // Extract query parameters (works for both API Gateway v2 and Function URL)
                  const queryParams = event.queryStringParameters || {};
                  const targetUrl = queryParams.url;

                  if (!targetUrl) {
                      console.error('Missing url parameter. Query params:', JSON.stringify(queryParams));
                      return {
                          statusCode: 400,
                          headers: headers,
                          body: JSON.stringify({ error: "Missing 'url' query parameter" })
                      };
                  }

                  console.log(`Proxying request to: ${targetUrl}`);

                  const parsedUrl = url.parse(targetUrl);
                  const options = {
                      hostname: parsedUrl.hostname,
                      port: parsedUrl.port || 443,
                      path: parsedUrl.path,
                      method: 'GET',
                      headers: {
                          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
                          'Accept': 'application/json, text/plain, */*',
                          'Accept-Language': 'en-US,en;q=0.9',
                          'Referer': 'https://intradayscreener.com/'
                      }
                  };

                  return new Promise((resolve, reject) => {
                      const req = https.request(options, (res) => {
                          let data = '';
                          res.on('data', (chunk) => {
                              data += chunk;
                          });
                          res.on('end', () => {
                              console.log(`Response status: ${res.statusCode}`);
                              resolve({
                                  statusCode: res.statusCode,
                                  headers: headers,
                                  body: data
                              });
                          });
                      });

                      req.on('error', (e) => {
                          console.error(`Error requesting ${targetUrl}: ${e.message}`);
                          resolve({
                              statusCode: 500,
                              headers: headers,
                              body: JSON.stringify({ error: `Internal Server Error: ${e.message}` })
                          });
                      });

                      req.end();
                  });

              } catch (error) {
                  console.error("Handler error:", error);
                  return {
                      statusCode: 500,
                      headers: headers,
                      body: JSON.stringify({ error: "Internal Server Error", details: error.message })
                  };
              }
          };
      Handler: index.handler
      Runtime: nodejs24.x
      Timeout: 10
      Role: !GetAtt ProxyFunctionRole.Arn

  # Lambda Execution Role
  ProxyFunctionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole

  # API Gateway HTTP API
  ProxyApi:
    Type: AWS::ApiGatewayV2::Api
    Properties:
      Name: price-action-proxy-api
      ProtocolType: HTTP
      CorsConfiguration:
        AllowOrigins:
          - 'https://price-action-tamil.com'
          - 'https://www.price-action-tamil.com'
        AllowMethods:
          - GET
          - OPTIONS
        AllowHeaders:
          - '*'
        MaxAge: 86400

  # API Gateway Integration
  ProxyIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref ProxyApi
      IntegrationType: AWS_PROXY
      IntegrationUri: !GetAtt ProxyFunction.Arn
      PayloadFormatVersion: '2.0'

  # API Gateway Route
  ProxyRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref ProxyApi
      RouteKey: 'GET /proxy'
      Target: !Sub 'integrations/${ProxyIntegration}'

  # API Gateway Stage
  ProxyStage:
    Type: AWS::ApiGatewayV2::Stage
    Properties:
      ApiId: !Ref ProxyApi
      StageName: '$default'
      AutoDeploy: true

  # Lambda Permission for API Gateway
  ProxyFunctionApiPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref ProxyFunction
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ProxyApi}/*/*'

  # Request Processor Lambda Function
  RequestProcessorFunction:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: |
          exports.handler = async (event) => {
              console.log('Received event:', JSON.stringify(event, null, 2));
              
              try {
                  const body = JSON.parse(event.body || '{}');
                  console.log('Request body:', JSON.stringify(body, null, 2));
                  
                  // For now, just log and return success
                  return {
                      statusCode: 200,
                      headers: {
                          'Content-Type': 'application/json',
                          'Access-Control-Allow-Origin': '*'
                      },
                      body: JSON.stringify({
                          success: true,
                          message: 'Request received successfully'
                      })
                  };
              } catch (error) {
                  console.error('Error:', error);
                  return {
                      statusCode: 500,
                      headers: {
                          'Content-Type': 'application/json',
                          'Access-Control-Allow-Origin': '*'
                      },
                      body: JSON.stringify({
                          success: false,
                          error: error.message
                      })
                  };
              }
          };
      Handler: index.handler
      Runtime: nodejs24.x
      Timeout: 10
      Role: !GetAtt RequestProcessorRole.Arn

  # Request Processor IAM Role
  RequestProcessorRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole

  # API Authorizer Lambda Function
  ApiAuthorizerFunction:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: |
          exports.handler = async (event) => {
              console.log('Authorizer event:', JSON.stringify(event, null, 2));
              
              const token = event.headers?.authorization || event.headers?.Authorization;
              const expectedApiKey = process.env.API_KEY;
              
              // Simple API key validation
              const isAuthorized = token === `Bearer ${expectedApiKey}`;
              
              return {
                  isAuthorized: isAuthorized,
                  context: {
                      userId: isAuthorized ? 'authenticated-user' : 'anonymous'
                  }
              };
          };
      Handler: index.handler
      Runtime: nodejs24.x
      Timeout: 5
      Role: !GetAtt ApiAuthorizerRole.Arn
      Environment:
        Variables:
          API_KEY: 'pat-api-key-2026-secure'

  # API Authorizer IAM Role
  ApiAuthorizerRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole

  # API Gateway Authorizer
  ApiAuthorizer:
    Type: AWS::ApiGatewayV2::Authorizer
    Properties:
      ApiId: !Ref ProxyApi
      AuthorizerType: REQUEST
      AuthorizerUri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${ApiAuthorizerFunction.Arn}/invocations'
      AuthorizerPayloadFormatVersion: '2.0'
      AuthorizerResultTtlInSeconds: 300
      EnableSimpleResponses: true
      IdentitySource:
        - '$request.header.Authorization'
      Name: api-key-authorizer

  # Lambda Permission for Authorizer
  AuthorizerPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref ApiAuthorizerFunction
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ProxyApi}/authorizers/${ApiAuthorizer}'

  # Community Join Integration
  CommunityJoinIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref ProxyApi
      IntegrationType: AWS_PROXY
      IntegrationUri: !GetAtt RequestProcessorFunction.Arn
      PayloadFormatVersion: '2.0'

  # Community Join Route (Protected)
  CommunityJoinRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref ProxyApi
      RouteKey: 'POST /community/join'
      Target: !Sub 'integrations/${CommunityJoinIntegration}'
      AuthorizationType: CUSTOM
      AuthorizerId: !Ref ApiAuthorizer

  # Lambda Permission for Community Join
  CommunityJoinPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref RequestProcessorFunction
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ProxyApi}/*/*'


Outputs:
  WebsiteURL:
    Value: !Sub 'https://${DomainName}'
    Description: 'URL for website hosted on S3 via CloudFront'
  S3BucketName:
    Value: !Ref WebsiteBucket
    Description: 'Name of S3 bucket to hold website content'
  CloudFrontDistributionId:
    Value: !Ref WebsiteDistribution
    Description: 'ID of the CloudFront Distribution'
  ApiUrl:
    Value: !Sub 'https://${ProxyApi}.execute-api.${AWS::Region}.amazonaws.com/proxy'
    Description: 'URL of the Proxy API Gateway'
