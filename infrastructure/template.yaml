AWSTemplateFormatVersion: '2010-09-09'
Description: 'CloudFormation template to host a static website in an S3 bucket served via CloudFront with a custom domain.'

Parameters:
  BucketName:
    Type: String
    Description: 'The name for the S3 bucket. Must be globally unique.'
    Default: 'price-action-tamil-site'
  DomainName:
    Type: String
    Description: 'The custom domain name for the website'
    Default: 'price-action-tamil.com'
  HostedZoneId:
    Type: String
    Description: 'The Route53 Hosted Zone ID'
    Default: 'Z03717392X1FRLNERFR2F'
  CertificateArn:
    Type: String
    Description: 'The ARN of the ACM Certificate (must be in us-east-1)'

Resources:
  # S3 Bucket Configuration
  WebsiteBucket:
    Type: 'AWS::S3::Bucket'
    Properties:
      BucketName: !Ref BucketName
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true

  # CloudFront Origin Access Identity (OAI)
  CloudFrontOriginAccessIdentity:
    Type: 'AWS::CloudFront::CloudFrontOriginAccessIdentity'
    Properties:
      CloudFrontOriginAccessIdentityConfig:
        Comment: !Sub 'Access identity for ${DomainName}'

  # S3 Bucket Policy
  WebsiteBucketPolicy:
    Type: 'AWS::S3::BucketPolicy'
    Properties:
      Bucket: !Ref WebsiteBucket
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Sid: GrantCloudFrontAccess
            Effect: Allow
            Principal:
              AWS: !Sub 'arn:aws:iam::cloudfront:user/CloudFront Origin Access Identity ${CloudFrontOriginAccessIdentity}'
            Action: 's3:GetObject'
            Resource: !Join 
              - ''
              - - 'arn:aws:s3:::'
                - !Ref WebsiteBucket
                - '/*'

  # CloudFront Distribution
  WebsiteDistribution:
    Type: 'AWS::CloudFront::Distribution'
    Properties:
      DistributionConfig:
        Origins:
          - Id: S3Origin
            DomainName: !GetAtt WebsiteBucket.DomainName
            S3OriginConfig:
              OriginAccessIdentity: !Sub 'origin-access-identity/cloudfront/${CloudFrontOriginAccessIdentity}'
        Enabled: true
        DefaultRootObject: index.html
        Aliases:
          - !Ref DomainName
          - !Sub 'www.${DomainName}'
        CustomErrorResponses:
          - ErrorCode: 403
            ResponseCode: 200
            ResponsePagePath: /index.html
          - ErrorCode: 404
            ResponseCode: 200
            ResponsePagePath: /index.html
        DefaultCacheBehavior:
          TargetOriginId: S3Origin
          ForwardedValues:
            QueryString: false
            Cookies:
              Forward: none
          ViewerProtocolPolicy: redirect-to-https
          Compress: true
        ViewerCertificate:
          AcmCertificateArn: !Ref CertificateArn
          SslSupportMethod: sni-only
          MinimumProtocolVersion: TLSv1.2_2021



  # Route53 Record (Apex)
  WebsiteDNS:
    Type: 'AWS::Route53::RecordSet'
    Properties:
      HostedZoneId: !Ref HostedZoneId
      Name: !Ref DomainName
      Type: A
      AliasTarget:
        HostedZoneId: Z2FDTNDATAQYW2
        DNSName: !GetAtt WebsiteDistribution.DomainName

  # WWW Record
  WebsiteDNSWWW:
    Type: 'AWS::Route53::RecordSet'
    Properties:
      HostedZoneId: !Ref HostedZoneId
      Name: !Sub 'www.${DomainName}'
      Type: A
      AliasTarget:
        HostedZoneId: Z2FDTNDATAQYW2
        DNSName: !GetAtt WebsiteDistribution.DomainName

  # Proxy Lambda Function
  ProxyFunction:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: |
          const https = require('https');
          const url = require('url');

          exports.handler = async (event) => {
              console.log('Event:', JSON.stringify(event, null, 2));
              
              const headers = {
                  "Access-Control-Allow-Origin": "*",
                  "Access-Control-Allow-Headers": "Content-Type",
                  "Access-Control-Allow-Methods": "GET, OPTIONS"
              };

              // Handle OPTIONS preflight
              const method = event.requestContext?.http?.method || event.httpMethod;
              if (method === 'OPTIONS') {
                  return {
                      statusCode: 200,
                      headers: headers,
                      body: JSON.stringify({ message: "OPTIONS OK" })
                  };
              }

              try {
                  // Extract query parameters (works for both API Gateway v2 and Function URL)
                  const queryParams = event.queryStringParameters || {};
                  const targetUrl = queryParams.url;

                  if (!targetUrl) {
                      console.error('Missing url parameter. Query params:', JSON.stringify(queryParams));
                      return {
                          statusCode: 400,
                          headers: headers,
                          body: JSON.stringify({ error: "Missing 'url' query parameter" })
                      };
                  }

                  console.log(`Proxying request to: ${targetUrl}`);

                  const parsedUrl = url.parse(targetUrl);
                  const isNSE = parsedUrl.hostname.includes('nseindia.com');
                  
                  const options = {
                      hostname: parsedUrl.hostname,
                      port: parsedUrl.port || 443,
                      path: parsedUrl.path,
                      method: 'GET',
                      headers: {
                          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
                          'Accept': 'application/json, text/plain, */*',
                          'Accept-Language': 'en-US,en;q=0.9',
                          'Referer': isNSE ? 'https://www.nseindia.com/' : 'https://intradayscreener.com/',
                          'Connection': 'keep-alive'
                      }
                  };

                  return new Promise((resolve, reject) => {
                      const req = https.request(options, (res) => {
                          let data = '';
                          res.on('data', (chunk) => {
                              data += chunk;
                          });
                          res.on('end', () => {
                              console.log(`Response status: ${res.statusCode}`);
                              resolve({
                                  statusCode: res.statusCode,
                                  headers: headers,
                                  body: data
                              });
                          });
                      });

                      req.on('error', (e) => {
                          console.error(`Error requesting ${targetUrl}: ${e.message}`);
                          resolve({
                              statusCode: 500,
                              headers: headers,
                              body: JSON.stringify({ error: `Internal Server Error: ${e.message}` })
                          });
                      });

                      req.end();
                  });

              } catch (error) {
                  console.error("Handler error:", error);
                  return {
                      statusCode: 500,
                      headers: headers,
                      body: JSON.stringify({ error: "Internal Server Error", details: error.message })
                  };
              }
          };
      Handler: index.handler
      Runtime: nodejs24.x
      Timeout: 10
      Role: !GetAtt ProxyFunctionRole.Arn

  # Lambda Execution Role
  ProxyFunctionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole

  # API Gateway HTTP API
  ProxyApi:
    Type: AWS::ApiGatewayV2::Api
    Properties:
      Name: price-action-proxy-api
      ProtocolType: HTTP
      CorsConfiguration:
        AllowOrigins:
          - 'https://price-action-tamil.com'
          - 'https://www.price-action-tamil.com'
        AllowMethods:
          - GET
          - POST
          - PUT
          - DELETE
          - OPTIONS
        AllowHeaders:
          - '*'
        MaxAge: 86400

  # API Gateway Integration
  ProxyIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref ProxyApi
      IntegrationType: AWS_PROXY
      IntegrationUri: !GetAtt ProxyFunction.Arn
      PayloadFormatVersion: '2.0'

  # API Gateway Route
  ProxyRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref ProxyApi
      RouteKey: 'GET /proxy'
      Target: !Sub 'integrations/${ProxyIntegration}'

  # API Gateway Stage
  ProxyStage:
    Type: AWS::ApiGatewayV2::Stage
    Properties:
      ApiId: !Ref ProxyApi
      StageName: '$default'
      AutoDeploy: true

  # Lambda Permission for API Gateway
  ProxyFunctionApiPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref ProxyFunction
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ProxyApi}/*/*'

  # Request Processor Lambda Function
  RequestProcessorFunction:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: |
          exports.handler = async (event) => {
              console.log('Received event:', JSON.stringify(event, null, 2));
              
              try {
                  const body = JSON.parse(event.body || '{}');
                  console.log('Request body:', JSON.stringify(body, null, 2));
                  
                  // For now, just log and return success
                  return {
                      statusCode: 200,
                      headers: {
                          'Content-Type': 'application/json',
                          'Access-Control-Allow-Origin': '*'
                      },
                      body: JSON.stringify({
                          success: true,
                          message: 'Request received successfully'
                      })
                  };
              } catch (error) {
                  console.error('Error:', error);
                  return {
                      statusCode: 500,
                      headers: {
                          'Content-Type': 'application/json',
                          'Access-Control-Allow-Origin': '*'
                      },
                      body: JSON.stringify({
                          success: false,
                          error: error.message
                      })
                  };
              }
          };
      Handler: index.handler
      Runtime: nodejs24.x
      Timeout: 10
      Role: !GetAtt RequestProcessorRole.Arn

  # Request Processor IAM Role
  RequestProcessorRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole

  # API Authorizer Lambda Function
  ApiAuthorizerFunction:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: |
          exports.handler = async (event) => {
              console.log('Authorizer event:', JSON.stringify(event, null, 2));
              
              const token = event.headers?.authorization || event.headers?.Authorization;
              const expectedApiKey = process.env.API_KEY;
              
              // Simple API key validation
              const isAuthorized = token === `Bearer ${expectedApiKey}`;
              
              return {
                  isAuthorized: isAuthorized,
                  context: {
                      userId: isAuthorized ? 'authenticated-user' : 'anonymous'
                  }
              };
          };
      Handler: index.handler
      Runtime: nodejs24.x
      Timeout: 5
      Role: !GetAtt ApiAuthorizerRole.Arn
      Environment:
        Variables:
          API_KEY: 'pat-api-key-2026-secure'

  # API Authorizer IAM Role
  ApiAuthorizerRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole

  # API Gateway Authorizer
  ApiAuthorizer:
    Type: AWS::ApiGatewayV2::Authorizer
    Properties:
      ApiId: !Ref ProxyApi
      AuthorizerType: REQUEST
      AuthorizerUri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${ApiAuthorizerFunction.Arn}/invocations'
      AuthorizerPayloadFormatVersion: '2.0'
      AuthorizerResultTtlInSeconds: 300
      EnableSimpleResponses: true
      IdentitySource:
        - '$request.header.Authorization'
      Name: api-key-authorizer

  # Lambda Permission for Authorizer
  AuthorizerPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref ApiAuthorizerFunction
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ProxyApi}/authorizers/${ApiAuthorizer}'

  # Community Join Integration
  CommunityJoinIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref ProxyApi
      IntegrationType: AWS_PROXY
      IntegrationUri: !GetAtt RequestProcessorFunction.Arn
      PayloadFormatVersion: '2.0'

  # Community Join Route (Protected)
  CommunityJoinRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref ProxyApi
      RouteKey: 'POST /community/join'
      Target: !Sub 'integrations/${CommunityJoinIntegration}'
      AuthorizationType: CUSTOM
      AuthorizerId: !Ref ApiAuthorizer

  # Lambda Permission for Community Join
  CommunityJoinPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref RequestProcessorFunction
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ProxyApi}/*/*'

  # Users DynamoDB Table
  UsersTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: pctrader-users
      AttributeDefinitions:
        - AttributeName: email
          AttributeType: S
      KeySchema:
        - AttributeName: email
          KeyType: HASH
      BillingMode: PAY_PER_REQUEST

  # Courses DynamoDB Table
  CoursesTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: pctrader-courses
      AttributeDefinitions:
        - AttributeName: courseId
          AttributeType: S
      KeySchema:
        - AttributeName: courseId
          KeyType: HASH
      BillingMode: PAY_PER_REQUEST

  # Course Content S3 Bucket
  CourseContentBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub 'pctrader-courses-${AWS::AccountId}-${AWS::Region}'
      CorsConfiguration:
        CorsRules:
          - AllowedHeaders: ['*']
            AllowedMethods: [GET, PUT, POST, DELETE, HEAD]
            AllowedOrigins: 
              - 'https://price-action-tamil.com'
              - 'https://www.price-action-tamil.com'
              - 'http://localhost:5173'
            MaxAge: 3000

  # Admin User Creation Lambda
  AdminUserFunction:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: |
          const { CognitoIdentityProviderClient, AdminCreateUserCommand, AdminDeleteUserCommand } = require("@aws-sdk/client-cognito-identity-provider");
          const { DynamoDBClient, PutItemCommand, ScanCommand, UpdateItemCommand, GetItemCommand, DeleteItemCommand } = require("@aws-sdk/client-dynamodb");
          const { S3Client, GetObjectCommand } = require("@aws-sdk/client-s3");
          const { getSignedUrl } = require("@aws-sdk/s3-request-presigner");
          
          const cognitoClient = new CognitoIdentityProviderClient({});
          const dbClient = new DynamoDBClient({});
          const s3Client = new S3Client({});

          exports.handler = async (event) => {
              console.log('Event:', JSON.stringify(event, null, 2));
              
              const headers = {
                  "Access-Control-Allow-Origin": "*",
                  "Access-Control-Allow-Headers": "Content-Type,Authorization",
                  "Access-Control-Allow-Methods": "GET,POST,OPTIONS"
              };

              const method = event.requestContext?.http?.method || event.httpMethod;
              const routeKey = event.requestContext?.routeKey || `${method} ${event.rawPath || event.path}`;

              if (method === 'OPTIONS') return { statusCode: 200, headers, body: '' };

              try {
                  // LIST/SEARCH USERS
                  if (routeKey === 'GET /admin/users') {
                      const result = await dbClient.send(new ScanCommand({ TableName: process.env.USERS_TABLE }));
                      const users = result.Items?.map(item => ({
                          email: item.email?.S,
                          phone: item.phone?.S,
                          role: item.role?.S,
                          status: item.status?.S,
                          createdAt: item.createdAt?.S,
                          courses: item.courses?.L?.map(c => ({
                              courseId: c.M?.courseId?.S,
                              courseTitle: c.M?.courseTitle?.S,
                              expiryDate: c.M?.expiryDate?.S
                          })) || []
                      })) || [];
                      return { statusCode: 200, headers, body: JSON.stringify(users) };
                  }

                  // CREATE USER
                  if (routeKey === 'POST /admin/create-user') {
                      const body = JSON.parse(event.body || '{}');
                      const { email, phone } = body;

                      if (!email) {
                          return { statusCode: 400, headers, body: JSON.stringify({ error: "Email is required" }) };
                      }

                      const userAttributes = [
                          { Name: "email", Value: email },
                          { Name: "email_verified", Value: "true" },
                          { Name: "custom:role", Value: "Student" }
                      ];

                      let formattedPhone = "";
                      if (phone && phone.trim()) {
                          formattedPhone = phone.trim().replace(/[\s-]/g, '');
                          if (!formattedPhone.startsWith('+')) {
                              if (formattedPhone.length === 10 && /^\d+$/.test(formattedPhone)) {
                                  formattedPhone = '+91' + formattedPhone;
                              } else if (/^\d+$/.test(formattedPhone)) {
                                  formattedPhone = '+' + formattedPhone;
                              }
                          }
                          userAttributes.push({ Name: "phone_number", Value: formattedPhone });
                      }

                      // 1. Create user in Cognito
                      await cognitoClient.send(new AdminCreateUserCommand({
                          UserPoolId: process.env.USER_POOL_ID,
                          Username: email,
                          UserAttributes: userAttributes,
                          DesiredDeliveryMediums: ["EMAIL"]
                      }));

                      // 2. Sync to DynamoDB
                      await dbClient.send(new PutItemCommand({
                          TableName: process.env.USERS_TABLE,
                          Item: {
                              email: { S: email },
                              phone: { S: formattedPhone },
                              role: { S: "Student" },
                              createdAt: { S: new Date().toISOString() },
                              courses: { L: [] },
                              status: { S: "Active" }
                          }
                      }));

                      return { statusCode: 200, headers, body: JSON.stringify({ message: "User created and synced successfully" }) };
                  }

                  // ASSIGN COURSE
                  if (routeKey === 'POST /admin/assign-course') {
                      const body = JSON.parse(event.body || '{}');
                      const { email, courseId } = body;

                      if (!email || !courseId) {
                          return { statusCode: 400, headers, body: JSON.stringify({ error: "Email and courseId are required" }) };
                      }

                      // 1. Get Course details for validity
                      const courseResult = await dbClient.send(new GetItemCommand({
                          TableName: process.env.COURSES_TABLE,
                          Key: { courseId: { S: courseId } }
                      }));

                      if (!courseResult.Item) {
                          return { statusCode: 404, headers, body: JSON.stringify({ error: "Course not found" }) };
                      }

                      const courseName = courseResult.Item.name?.S;
                      const validity = courseResult.Item.validity?.S || "3 months";

                      // 2. Calculate Expiry
                      const expiry = new Date();
                      const valMatch = validity.match(/(\d+)\s*(month|year)/);
                      if (valMatch) {
                          const num = parseInt(valMatch[1]);
                          const unit = valMatch[2];
                          if (unit === 'month') expiry.setMonth(expiry.getMonth() + num);
                          if (unit === 'year') expiry.setFullYear(expiry.getFullYear() + num);
                      } else {
                          expiry.setMonth(expiry.getMonth() + 3); // Default 3 months
                      }
                      const expiryDate = expiry.toISOString().split('T')[0];
                      
                      // 2.5 Check if user already has this course
                      const userResult = await dbClient.send(new GetItemCommand({
                          TableName: process.env.USERS_TABLE,
                          Key: { email: { S: email } }
                      }));
                      
                      if (userResult.Item && userResult.Item.courses?.L) {
                          const alreadyHas = userResult.Item.courses.L.some(c => c.M?.courseId?.S === courseId);
                          if (alreadyHas) {
                              return { statusCode: 400, headers, body: JSON.stringify({ error: "Course already assigned to this user" }) };
                          }
                      }

                      // 3. Update User with course
                      await dbClient.send(new UpdateItemCommand({
                          TableName: process.env.USERS_TABLE,
                          Key: { email: { S: email } },
                          UpdateExpression: "SET courses = list_append(if_not_exists(courses, :empty_list), :new_course)",
                          ExpressionAttributeValues: {
                              ":new_course": { L: [{ M: {
                                  courseId: { S: courseId },
                                  courseTitle: { S: courseName },
                                  expiryDate: { S: expiryDate }
                              }}]},
                              ":empty_list": { L: [] }
                          }
                      }));

                      return { statusCode: 200, headers, body: JSON.stringify({ message: "Course assigned successfully", expiryDate }) };
                  }

                  // GET STUDENT COURSES
                  if (routeKey === 'GET /student/courses') {
                      const email = event.queryStringParameters?.email;
                      if (!email) {
                          return { statusCode: 400, headers, body: JSON.stringify({ error: "Email is required" }) };
                      }

                      // 1. Get User
                      const userResult = await dbClient.send(new GetItemCommand({
                          TableName: process.env.USERS_TABLE,
                          Key: { email: { S: email } }
                      }));

                      if (!userResult.Item) {
                          return { statusCode: 404, headers, body: JSON.stringify({ error: "User not found" }) };
                      }

                      const userCourses = userResult.Item.courses?.L || [];
                      const detailedCourses = [];

                      // 2. Fetch full course details for each assignment
                      for (const c of userCourses) {
                          const cId = c.M?.courseId?.S;
                          const exp = c.M?.expiryDate?.S;

                          const courseDef = await dbClient.send(new GetItemCommand({
                              TableName: process.env.COURSES_TABLE,
                              Key: { courseId: { S: cId } }
                          }));

                          if (courseDef.Item) {
                              const recordings = [];
                              const recsList = courseDef.Item.recordings?.L || [];

                              // Generate presigned URLs for each recording
                              for (const rec of recsList) {
                                  const title = rec.M?.title?.S;
                                  const s3Key = rec.M?.s3Key?.S;
                                  
                                  const command = new GetObjectCommand({
                                      Bucket: process.env.COURSE_BUCKET,
                                      Key: s3Key
                                  });
                                  const url = await getSignedUrl(s3Client, command, { expiresIn: 21600 }); // 6 hours

                                  recordings.push({ title, url });
                              }

                              detailedCourses.push({
                                  courseId: cId,
                                  name: courseDef.Item.name?.S,
                                  expiryDate: exp,
                                  recordings: recordings
                              });
                          }
                      }

                      return { statusCode: 200, headers, body: JSON.stringify(detailedCourses) };
                  }

                  // REMOVE COURSE
                  if (routeKey === 'POST /admin/remove-course') {
                      const body = JSON.parse(event.body || '{}');
                      const { email, courseId } = body;

                      if (!email || !courseId) {
                          return { statusCode: 400, headers, body: JSON.stringify({ error: "Email and courseId are required" }) };
                      }

                      // 1. Get User to find the index or filter
                      const userResult = await dbClient.send(new GetItemCommand({
                          TableName: process.env.USERS_TABLE,
                          Key: { email: { S: email } }
                      }));

                      if (!userResult.Item) {
                          return { statusCode: 404, headers, body: JSON.stringify({ error: "User not found" }) };
                      }

                      const currentCourses = userResult.Item.courses?.L || [];
                      const updatedCourses = currentCourses.filter(c => c.M?.courseId?.S !== courseId);

                      // 2. Update User
                      await dbClient.send(new UpdateItemCommand({
                          TableName: process.env.USERS_TABLE,
                          Key: { email: { S: email } },
                          UpdateExpression: "SET courses = :updated_courses",
                          ExpressionAttributeValues: {
                              ":updated_courses": { L: updatedCourses }
                          }
                      }));

                      return { statusCode: 200, headers, body: JSON.stringify({ message: "Course removed successfully" }) };
                  }

                  // DELETE USER
                  if (routeKey === 'DELETE /admin/delete-user') {
                      const email = event.queryStringParameters?.email || JSON.parse(event.body || '{}').email;
                      if (!email) {
                          return { statusCode: 400, headers, body: JSON.stringify({ error: "Email is required" }) };
                      }

                      // 1. Delete from Cognito
                      try {
                          await cognitoClient.send(new AdminDeleteUserCommand({
                              UserPoolId: process.env.USER_POOL_ID,
                              Username: email
                          }));
                      } catch (cErr) {
                          console.log('Cognito delete error (might already be gone):', cErr.message);
                      }

                      // 2. Delete from DynamoDB
                      await dbClient.send(new DeleteItemCommand({
                          TableName: process.env.USERS_TABLE,
                          Key: { email: { S: email } }
                      }));

                      return { statusCode: 200, headers, body: JSON.stringify({ message: "User deleted successfully" }) };
                  }

                  return { statusCode: 404, headers, body: JSON.stringify({ error: "Route not found" }) };

              } catch (error) {
                  console.error(error);
                  return { statusCode: 500, headers, body: JSON.stringify({ error: error.message }) };
              }
          };
      Handler: index.handler
      Runtime: nodejs24.x
      Timeout: 15
      Role: !GetAtt AdminUserFunctionRole.Arn
      Environment:
        Variables:
          USER_POOL_ID: !Ref UserPool
          USERS_TABLE: !Ref UsersTable
          COURSES_TABLE: !Ref CoursesTable
          COURSE_BUCKET: !Ref CourseContentBucket

  # IAM Role for Admin User Creation
  AdminUserFunctionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: CognitoAdminPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - cognito-idp:AdminCreateUser
                  - cognito-idp:AdminAddUserToGroup
                  - cognito-idp:AdminDeleteUser
                Resource: !GetAtt UserPool.Arn
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                  - dynamodb:UpdateItem
                  - dynamodb:Scan
                  - dynamodb:GetItem
                  - dynamodb:DeleteItem
                Resource: 
                  - !GetAtt UsersTable.Arn
                  - !GetAtt CoursesTable.Arn
              - Effect: Allow
                Action:
                  - s3:GetObject
                Resource: !Sub 'arn:aws:s3:::${CourseContentBucket}/*'

  # API Gateway Integration for Admin User Creation
  AdminUserIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref ProxyApi
      IntegrationType: AWS_PROXY
      IntegrationUri: !GetAtt AdminUserFunction.Arn
      PayloadFormatVersion: '2.0'

  # API Gateway Route for Admin User Creation
  AdminUserRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref ProxyApi
      RouteKey: 'POST /admin/create-user'
      Target: !Sub 'integrations/${AdminUserIntegration}'
      AuthorizationType: CUSTOM
      AuthorizerId: !Ref ApiAuthorizer

  # GET /admin/users (Search/List)
  UserListRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref ProxyApi
      RouteKey: 'GET /admin/users'
      Target: !Sub 'integrations/${AdminUserIntegration}'
      AuthorizationType: CUSTOM
      AuthorizerId: !Ref ApiAuthorizer

  # POST /admin/assign-course
  CourseAssignRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref ProxyApi
      RouteKey: 'POST /admin/assign-course'
      Target: !Sub 'integrations/${AdminUserIntegration}'
      AuthorizationType: CUSTOM
      AuthorizerId: !Ref ApiAuthorizer

  # GET /student/courses
  StudentCourseRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref ProxyApi
      RouteKey: 'GET /student/courses'
      Target: !Sub 'integrations/${AdminUserIntegration}'
      AuthorizationType: CUSTOM
      AuthorizerId: !Ref ApiAuthorizer

  # POST /admin/remove-course
  RemoveCourseRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref ProxyApi
      RouteKey: 'POST /admin/remove-course'
      Target: !Sub 'integrations/${AdminUserIntegration}'
      AuthorizationType: CUSTOM
      AuthorizerId: !Ref ApiAuthorizer

  # DELETE /admin/delete-user
  DeleteUserRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref ProxyApi
      RouteKey: 'DELETE /admin/delete-user'
      Target: !Sub 'integrations/${AdminUserIntegration}'
      AuthorizationType: CUSTOM
      AuthorizerId: !Ref ApiAuthorizer

  # Course Management Integration
  CourseManagementIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref ProxyApi
      IntegrationType: AWS_PROXY
      IntegrationUri: !GetAtt CourseManagementFunction.Arn
      PayloadFormatVersion: '2.0'

  # GET /admin/courses (List)
  CourseListRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref ProxyApi
      RouteKey: 'GET /admin/courses'
      Target: !Sub 'integrations/${CourseManagementIntegration}'
      AuthorizationType: CUSTOM
      AuthorizerId: !Ref ApiAuthorizer

  # POST /admin/courses/upload-url (Get Presigned URL)
  CourseUploadUrlRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref ProxyApi
      RouteKey: 'POST /admin/courses/upload-url'
      Target: !Sub 'integrations/${CourseManagementIntegration}'
      AuthorizationType: CUSTOM
      AuthorizerId: !Ref ApiAuthorizer

  # POST /admin/courses (Create Meta)
  CourseCreateRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref ProxyApi
      RouteKey: 'POST /admin/courses'
      Target: !Sub 'integrations/${CourseManagementIntegration}'
      AuthorizationType: CUSTOM
      AuthorizerId: !Ref ApiAuthorizer

  # PUT /admin/courses/{courseId} (Update)
  CourseUpdateRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref ProxyApi
      RouteKey: 'PUT /admin/courses/{id}'
      Target: !Sub 'integrations/${CourseManagementIntegration}'
      AuthorizationType: CUSTOM
      AuthorizerId: !Ref ApiAuthorizer

  # DELETE /admin/courses/{courseId} (Delete)
  CourseDeleteRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref ProxyApi
      RouteKey: 'DELETE /admin/courses/{id}'
      Target: !Sub 'integrations/${CourseManagementIntegration}'
      AuthorizationType: CUSTOM
      AuthorizerId: !Ref ApiAuthorizer

  # Course Management Lambda Function
  CourseManagementFunction:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: |
          const { DynamoDBClient, ScanCommand, PutItemCommand, UpdateItemCommand, DeleteItemCommand, GetItemCommand } = require("@aws-sdk/client-dynamodb");
          const { S3Client, PutObjectCommand } = require("@aws-sdk/client-s3");
          const { getSignedUrl } = require("@aws-sdk/s3-request-presigner");
          const crypto = require('crypto');

          const dbClient = new DynamoDBClient({});
          const s3Client = new S3Client({});

          exports.handler = async (event) => {
              console.log('Event:', JSON.stringify(event, null, 2));
              
              const headers = {
                  "Access-Control-Allow-Origin": "*",
                  "Access-Control-Allow-Headers": "Content-Type,Authorization",
                  "Access-Control-Allow-Methods": "GET,POST,PUT,DELETE,OPTIONS"
              };

              const method = event.requestContext?.http?.method || event.httpMethod;
              const routeKey = event.requestContext?.routeKey || `${method} ${event.rawPath || event.path}`;

              if (method === 'OPTIONS') return { statusCode: 200, headers };

              try {
                  // LIST COURSES
                  if (routeKey === 'GET /admin/courses') {
                      const result = await dbClient.send(new ScanCommand({ TableName: process.env.COURSES_TABLE }));
                      const courses = result.Items?.map(item => ({
                          courseId: item.courseId?.S,
                          name: item.name?.S,
                          price: item.price?.N,
                          validity: item.validity?.S,
                          recordings: item.recordings?.L?.map(rec => ({
                              title: rec.M?.title?.S,
                              s3Key: rec.M?.s3Key?.S
                          })) || [],
                          createdAt: item.createdAt?.S
                      })) || [];
                      return { statusCode: 200, headers, body: JSON.stringify(courses) };
                  }

                  // GET UPLOAD URL
                  if (routeKey === 'POST /admin/courses/upload-url') {
                      const body = JSON.parse(event.body || '{}');
                      const fileName = body.fileName || `video_${Date.now()}.mp4`;
                      const s3Key = `courses/${crypto.randomUUID()}/${fileName}`;
                      
                      const command = new PutObjectCommand({
                          Bucket: process.env.COURSE_BUCKET,
                          Key: s3Key,
                          ContentType: body.contentType || 'video/mp4'
                      });
                      
                      const uploadUrl = await getSignedUrl(s3Client, command, { expiresIn: 3600 });
                      return { statusCode: 200, headers, body: JSON.stringify({ uploadUrl, s3Key }) };
                  }

                  // CREATE COURSE
                  if (routeKey === 'POST /admin/courses') {
                      const body = JSON.parse(event.body || '{}');
                      const courseId = crypto.randomUUID();
                      const recordings = body.recordings?.map(rec => ({
                          M: {
                              title: { S: rec.title },
                              s3Key: { S: rec.s3Key }
                          }
                      })) || [];

                      await dbClient.send(new PutItemCommand({
                          TableName: process.env.COURSES_TABLE,
                          Item: {
                              courseId: { S: courseId },
                              name: { S: body.name },
                              price: { N: body.price.toString() },
                              validity: { S: body.validity },
                              recordings: { L: recordings },
                              createdAt: { S: new Date().toISOString() }
                          }
                      }));
                      return { statusCode: 201, headers, body: JSON.stringify({ message: "Course created", courseId }) };
                  }

                  // UPDATE COURSE
                  if (routeKey.startsWith('PUT /admin/courses/')) {
                      const id = event.pathParameters?.id;
                      const body = JSON.parse(event.body || '{}');
                      const recordings = body.recordings?.map(rec => ({
                          M: {
                              title: { S: rec.title },
                              s3Key: { S: rec.s3Key }
                          }
                      })) || [];

                      await dbClient.send(new UpdateItemCommand({
                          TableName: process.env.COURSES_TABLE,
                          Key: { courseId: { S: id } },
                          UpdateExpression: "SET #n = :n, price = :p, validity = :v, recordings = :r",
                          ExpressionAttributeNames: { "#n": "name" },
                          ExpressionAttributeValues: {
                              ":n": { S: body.name },
                              ":p": { N: body.price.toString() },
                              ":v": { S: body.validity },
                              ":r": { L: recordings }
                          }
                      }));
                      return { statusCode: 200, headers, body: JSON.stringify({ message: "Course updated" }) };
                  }

                  // DELETE COURSE
                  if (routeKey.startsWith('DELETE /admin/courses/')) {
                      const id = event.pathParameters?.id;
                      await dbClient.send(new DeleteItemCommand({
                          TableName: process.env.COURSES_TABLE,
                          Key: { courseId: { S: id } }
                      }));
                      return { statusCode: 200, headers, body: JSON.stringify({ message: "Course deleted" }) };
                  }

                  return { statusCode: 404, headers, body: JSON.stringify({ error: "Route not found", routeKey }) };

              } catch (error) {
                  console.error(error);
                  return { statusCode: 500, headers, body: JSON.stringify({ error: error.message }) };
              }
          };
      Handler: index.handler
      Runtime: nodejs24.x
      Timeout: 30
      Role: !GetAtt CourseManagementRole.Arn
      Environment:
        Variables:
          COURSES_TABLE: !Ref CoursesTable
          COURSE_BUCKET: !Ref CourseContentBucket

  # IAM Role for Course Management
  CourseManagementRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal: { Service: lambda.amazonaws.com }
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: CourseManagementPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:Scan
                  - dynamodb:PutItem
                  - dynamodb:UpdateItem
                  - dynamodb:DeleteItem
                  - dynamodb:GetItem
                Resource: !GetAtt CoursesTable.Arn
              - Effect: Allow
                Action:
                  - s3:PutObject
                  - s3:GetObject
                Resource: !Sub 'arn:aws:s3:::${CourseContentBucket}/*'

  # Lambda Permission for Course Management
  CourseManagementApiPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref CourseManagementFunction
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ProxyApi}/*/*'

  # Lambda Permission for API Gateway
  AdminUserFunctionApiPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref AdminUserFunction
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ProxyApi}/*/*'


  # Cognito User Pool
  UserPool:
    Type: AWS::Cognito::UserPool
    Properties:
      UserPoolName: pctrader-user-pool
      UsernameAttributes:
        - email
      AutoVerifiedAttributes:
        - email
      Policies:
        PasswordPolicy:
          MinimumLength: 8
          RequireLowercase: true
          RequireNumbers: true
          RequireSymbols: true
          RequireUppercase: true
      Schema:
        - Name: email
          AttributeDataType: String
          Mutable: true
          Required: true
        - Name: role
          AttributeDataType: String
          Mutable: true
          Required: false

  # Cognito User Pool Client
  UserPoolClient:
    Type: AWS::Cognito::UserPoolClient
    Properties:
      ClientName: pctrader-app-client
      UserPoolId: !Ref UserPool
      GenerateSecret: false
      ExplicitAuthFlows:
        - ALLOW_USER_PASSWORD_AUTH
        - ALLOW_REFRESH_TOKEN_AUTH
        - ALLOW_USER_SRP_AUTH

  # Cognito Admin Group
  AdminGroup:
    Type: AWS::Cognito::UserPoolGroup
    Properties:
      GroupName: Admins
      Description: Administrative users
      UserPoolId: !Ref UserPool

Outputs:
  WebsiteURL:
    Value: !Sub 'https://${DomainName}'
    Description: 'URL for website hosted on S3 via CloudFront'
  S3BucketName:
    Value: !Ref WebsiteBucket
    Description: 'Name of S3 bucket to hold website content'
  CloudFrontDistributionId:
    Value: !Ref WebsiteDistribution
    Description: 'ID of the CloudFront Distribution'
  ApiUrl:
    Value: !Sub 'https://${ProxyApi}.execute-api.${AWS::Region}.amazonaws.com/proxy'
    Description: 'URL of the Proxy API Gateway'
  UserPoolId:
    Value: !Ref UserPool
    Description: 'Cognito User Pool ID'
  UserPoolClientId:
    Value: !Ref UserPoolClient
    Description: 'Cognito User Pool Client ID'
